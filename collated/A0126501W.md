# A0126501W
###### Command.java
``` java
package cs2103;

public class Command {
	private String commandType;
	private String commandArgument;
	private Task newTask;
	private Task updatedTask;

	public Command() {
		newTask = new Task("");
		updatedTask = new Task("");
	}

	public String getCommandType() {
		return commandType;
	}

	public void setCommandType(String newCommandType) {
		commandType = newCommandType;
	}

	public String getCommandArgument() {
		return commandArgument;
	}

	public void setCommandArgument(String newCommandArgument) {
		commandArgument = newCommandArgument;
	}

	public Task getNewTask() {
		return newTask;
	}

	public void setNewTask(Task newNewTask) {
		newTask = newNewTask;
	}

	public Task getUpdatedTask() {
		return updatedTask;
	}

	public void setUpdatedTask(Task newUpdatedTask) {
		updatedTask = newUpdatedTask;
	}

}
```
###### CommandParser.java
``` java
package cs2103;
import java.util.*;

public class CommandParser {
	
    private int mPosition = -1;
	
	private DateTimeHelper mDateTimeHelper = new DateTimeHelper();

	public CommandParser() {
		
	}
	
	protected Command parse(String userCommand) {
		
		Command command = new Command();
		String commandType = getCommandType(userCommand);
		command.setCommandType(commandType);
		command.setCommandArgument(getCommandSecondArgument(userCommand));
		command.setNewTask(null);
		command.setUpdatedTask(null);
		String[] commands = userCommand.split(" ");
		
		switch (commandType) {
			
			case AppConst.COMMAND_TYPE.ADD:
				command.setNewTask(getTaskFromString(commandType, userCommand));
				break;
			
			case AppConst.COMMAND_TYPE.DONE:
			case AppConst.COMMAND_TYPE.UNDONE:
			case AppConst.COMMAND_TYPE.DELETE:
				if (commands.length < 2) {
					command.setNewTask(null);
				} else if (commands[1].equals(AppConst.TASK_FIELD.ID)) {
					if (commands.length < 3) {
						command.setNewTask(null);
					} else {
						String st = "";
						for(int i = 1; i < commands.length; i++) {
							if (i > 1) {
								st += " ";
							}
							st += commands[i];
						}
						command.setCommandArgument(st);
					}
				} else {
					command.setNewTask(getTaskFromString(commandType, userCommand));
				}
				break;
			case AppConst.COMMAND_TYPE.UPDATE:
				if (!userCommand.contains(AppConst.KEY_WORD.TO.toUpperCase())) {
					command.setNewTask(null);
					command.setUpdatedTask(null);
					break;
				}
				String oldTaskInfo = getOldTaskInfoForUpdate(userCommand);
				String newTaskInfo = getNewTaskInfoForUpdate(userCommand);
				if (oldTaskInfo.equals("") || newTaskInfo.equals("")) {
					command.setNewTask(null);
					command.setUpdatedTask(null);
					break;
				}
				if (!commands[1].equals(AppConst.TASK_FIELD.ID)) {
					oldTaskInfo = commandType + " " + oldTaskInfo;
					command.setNewTask(getTaskFromString(commandType, oldTaskInfo));
				} else {
					command.setCommandArgument(commands[1] + " " + commands[2]);
					command.setNewTask(null);
				}
				
				newTaskInfo = commandType + " " + newTaskInfo;
				command.setUpdatedTask(getTaskFromString(commandType, newTaskInfo));
				break;
			default:
				command.setCommandArgument(getCommandArgument(userCommand));
				
		}
		return command;
	}
	
	private String getOldTaskInfoForUpdate(String userCommand) {
		String[] splits = userCommand.split(" ");
		if (splits.length < 2) {
			return "";
		}
		String result = "";
		if (!splits[1].equals(AppConst.TASK_FIELD.ID)) {
			for (int i = 1; i < splits.length; i++) {
				if (splits[i].equals(AppConst.KEY_WORD.TO.toUpperCase())) {
					break;
				}
				if (result.length() > 0) {
					result += " ";
				}
				result += splits[i];
			}
			return result;
		} else {
			if (splits.length < 3) {
				return "";
			}
			for (int i = 0; i < splits[2].length(); i++) {
				if (splits[2].charAt(i) < '0' || splits[2].charAt(i) > '9') {
					return "";
				}
			}
			return splits[2];
		}
	}
	
	private String getNewTaskInfoForUpdate(String userCommand) {
		String[] splits = userCommand.split(" ");
		String result = "";
		for (int i = 1; i < splits.length; i++) {
			if (splits[i].equals(AppConst.KEY_WORD.TO.toUpperCase())) {
				for (int j = i + 1; j < splits.length; j++) {
					if (result.length() > 0) {
						result += " ";
					}
					result += splits[j];
				}
				break;
			}
		}
		return result;
	}

	private Task getTaskFromString(String commandType, String userCommand) {
		String[] splits = userCommand.split(" ");
		for (int i = 0; i < splits.length; i++) {
			if (splits[i].equals(AppConst.KEY_WORD.REPEAT)) {
				return getTaskRepeatFromString(commandType, userCommand);
			}
		}
		mPosition = -1;
		Task task = new Task("");
		String deadline = getDeadlineForTask(userCommand);
		String startDate = getStartDateForTask(userCommand);
		String endDate = getEndDateForTask(userCommand);
				
		// handle for from DateTime to DateTime of Month case
		// get Month from endDate, put to startDate
		if (startDate == null && endDate != null && !endDate.equals("")) {
			startDate = getStringDateForStartDate(userCommand);
			String month = mDateTimeHelper.getMonthStringForDateTime(endDate);
			startDate = mDateTimeHelper.getStringDateFromString(month + " " + startDate, 1);
			if (startDate == null || startDate.equals("")) {
				startDate = getStringDateForStartDate(userCommand);
				startDate = mDateTimeHelper.getTimeFromString(startDate, 1);
				if (startDate != null && !startDate.equals("")) {
					startDate = mDateTimeHelper.getDateMonthFromString(endDate, 1) + " " + startDate;
				}
			}
		}	
						
		String priority = getPriorityForTask(userCommand);
				
		if (priority != null && priority.equals("")) {
			// Default medium
			if (commandType.equals(AppConst.COMMAND_TYPE.ADD)) {
				priority = AppConst.TASK_FIELD.MEDIUM;
			}
		}
		
		if (!mDateTimeHelper.isCorrectDate(startDate)) {
			startDate = null;
		}
		if (!mDateTimeHelper.isCorrectDate(endDate)) {
			endDate = null;
		}
		if (!mDateTimeHelper.isCorrectDate(deadline)) {
			deadline = null;
		}
				
		task.setDeadline(deadline);
		task.setStartDate(startDate);
		task.setEndDate(endDate);
		task.setPriority(priority);
		task.setRepeatedType(0);
		task.setPeriod("");
		task.setGroup(getGroupForTask(userCommand));
		task.setTaskInfo(getCommandArgument(userCommand));
		task.setName(getTaskInfo(userCommand));
		return task;
	}
	
	private Task getTaskRepeatFromString(String commandType, String userCommand) {
		
		mPosition = -1;
		Task task = new Task("");
		
		String priority = getPriorityForTask(userCommand);
				
		if (priority != null && priority.equals("")) {
			// Default medium
			if (commandType.equals(AppConst.COMMAND_TYPE.ADD)) {
				priority = AppConst.TASK_FIELD.MEDIUM;
			}
		}
		
		String deadline = getDeadlineForTask(userCommand);
		if (deadline != null && !deadline.equals("")) {
			deadline = null;
		}
		
		int repeatedType = 1;
		String periodTime = getPeriodForTask(userCommand);
		
		String splits[] = userCommand.split(" ");
		int position = 0;
		for (int i = 0; i < splits.length; i++) {
			if (splits[i].equals(AppConst.KEY_WORD.REPEAT)) {
				position = i;
				break;
			}	
		}
		String startDate = null;
		String endDate = null;
		if (position < splits.length-1) {
			if (splits[position+1].equals(AppConst.KEY_WORD.FROM)) {
				startDate = getStartDateForPeriod(userCommand);
				endDate = getEndDateForPeriod(userCommand);
				if (startDate != null) {
					if (endDate == null) {
						endDate = AppConst.DATE_TIME.END_YEAR_DATE_TIME;
					}
				}
				repeatedType = 1;
			} else if (splits[position+1].equals(AppConst.DATE_TIME.EVERYDAY) || (splits[position+1].equals(AppConst.DATE_TIME.EVERY) && position+2<splits.length && splits[position+2].equals(AppConst.DATE_TIME.DAY)))  {
				repeatedType = 3;
				startDate = mDateTimeHelper.getCurrentTimeString();
				endDate = AppConst.DATE_TIME.END_YEAR_DATE_TIME;
			} else {
				repeatedType = 2;
				String day = "";
				if (splits[position+1].equals(AppConst.DATE_TIME.EVERY)) {
					if (position + 2 < splits.length) {
						day = mDateTimeHelper.getDateFromDayInCurrentWeek(splits[position+2]);
					}
				} else {
					day = mDateTimeHelper.getDateFromDayInCurrentWeek(splits[position+1]);
				}
				if (day != null) {
					startDate = day + " " + AppConst.DATE_TIME.START_TIME;
					endDate = day + " " + AppConst.DATE_TIME.END_TIME;
				}
			}
		}
		
		if (periodTime == null) {
			startDate = null;
			endDate = null;
		}
		
		task.setDeadline(deadline);
		task.setStartDate(startDate);
		task.setEndDate(endDate);
		task.setPeriod(periodTime);
		task.setRepeatedType(repeatedType);
		task.setPriority(priority);
		task.setGroup(getGroupForTask(userCommand));
		task.setTaskInfo(getCommandArgument(userCommand));
		task.setName(getTaskInfo(userCommand));
		
		return task;
	}

	private String getPeriodForTask(String userCommand) {
		String[] splits = userCommand.split(" ");
		int position = 0;
		for (int i = 0; i < splits.length; i++) {
			if (splits[i].equals(AppConst.KEY_WORD.REPEAT)) {
				position = i;
				if (mPosition == -1) {
					mPosition = i;
				} else {
					mPosition = Math.min(mPosition, i);
				}
				break;
			}
		}
		String startTime = "";
		for (int i = 0; i < position; i++) {
			if (splits[i].equals(AppConst.KEY_WORD.FROM)) {
				if (mPosition == -1) {
					mPosition = i;
				} else {
					mPosition = Math.min(mPosition, i);
				}
				for (int j = i + 1; j < position; j++) {
					if (splits[j].equals(AppConst.KEY_WORD.TO)) {
						break;
					} else {
						startTime += splits[j];
					}
				}
			}
		}
		
		
		String endTime = "";
		for (int i = 0; i < position; i++) {
			if (splits[i].equals(AppConst.KEY_WORD.TO)) {
				if (mPosition == -1) {
					mPosition = i;
				} else {
					mPosition = Math.min(mPosition, i);
				}
				for (int j = i + 1; j < position; j++) {
					if (splits[j].equals(AppConst.KEY_WORD.REPEAT)) {
						break;
					} else {
						endTime += splits[j];
					}
				}
			}
		}
		
		startTime = mDateTimeHelper.getTimeFromString(startTime, 1);
		endTime = mDateTimeHelper.getTimeFromString(endTime, 2);
		
		if (startTime == null || endTime == null || startTime.equals("") || endTime.equals("")) {
			return null;
		}
		if (startTime.compareTo(endTime)>=0) {
			return null;
		}
		return startTime + " " + endTime;
		
	}
	
	private String getStartDateForPeriod(String userCommand) {
	
		String[] splits = userCommand.toLowerCase().split(" ");
		int position = -1;
		for (int i = 0; i < splits.length; i++) {
			if (splits[i].equals(AppConst.KEY_WORD.REPEAT)) {
				position = i;
				if (mPosition == -1) {
					mPosition = i;
				} else {
					mPosition = Math.min(mPosition, i);
				}
				break;
			}
		}
		if (position == -1 || position > splits.length-1) {
			return null;
		}
		if (!splits[position+1].equals(AppConst.KEY_WORD.FROM)) {
			return null;
		}
		String startDate = "";
		for (int i = position + 2; i < splits.length; i++) {
			if (splits[i].equals(AppConst.KEY_WORD.TO)) {
				break;
			}
			if (i > position+2) {
				startDate += " ";
			}
			startDate += splits[i];
		}
		
		String result = mDateTimeHelper.getDateMonthFromString(startDate, 1);
		if (result == null || result.equals("")) {
			String endDate = getEndDateForPeriod(userCommand);
			if (endDate == null || endDate.equals("")) {
				return null;
			}
			startDate += mDateTimeHelper.getMonthStringForDateTime(endDate);
			result = mDateTimeHelper.getDateMonthFromString(startDate, 1);
		}
			
		return result + " " + AppConst.DATE_TIME.START_TIME;
	}
	
	private String getEndDateForPeriod(String userCommand) {
	
		String[] splits = userCommand.toLowerCase().split(" ");
		int position = 0;
		for (int i = 0; i < splits.length; i++) {
			if (splits[i].equals(AppConst.KEY_WORD.REPEAT)) {
				position = i;
				break;
			}
		}
		String endDate = "";
		for(int i = position+1; i < splits.length; i++) {
			if (splits[i].equals(AppConst.KEY_WORD.TO)) {
				for (int j = i + 1; j < splits.length; j++) {
					if (splits[j].equals(AppConst.KEY_WORD.PRIORITY) || splits[j].equals(AppConst.KEY_WORD.GROUP) || splits[j].equals(AppConst.KEY_WORD.GRP) || splits[j].equals(AppConst.KEY_WORD.BY) || splits[j].equals(AppConst.KEY_WORD.BEFORE)) {
						break;
					}
					endDate += " " + splits[j];
				}
				break;
			}
		}
	
		if (endDate.equals("")) {
			return null;
		}
		
		return mDateTimeHelper.getDateMonthFromString(endDate, 2) + " " + AppConst.DATE_TIME.END_TIME;
	}
	

    private String getDeadlineForTask(String userCommand) {
        String[] splits = userCommand.split(" ");
        for (int i = splits.length - 1; i >= 0; i--) {
            if (splits[i].equals(AppConst.KEY_WORD.BY) || splits[i].equals(AppConst.KEY_WORD.BEFORE)) {
                String result = "";
                if (mPosition == -1) {
   					mPosition = i;
   				} else {
   					mPosition = Math.min(mPosition, i);
   				}
   				if (i == splits.length-1) { 
   					continue;
   				}
                for (int j = i + 1; j < splits.length; j++) {
                    if (splits[j].equals(AppConst.KEY_WORD.GRP) || splits[j].equals(AppConst.KEY_WORD.GROUP) || splits[j].equals(AppConst.KEY_WORD.PRIORITY) || splits[j].equals(AppConst.KEY_WORD.FROM) || splits[j].equals(AppConst.KEY_WORD.TO)) {
                        break;
                    } else {
                        if (j != i + 1) {
                            result += " ";
                        }
                        result += splits[j];
                    }
                }
                if (!result.equals("")) {
                	result = mDateTimeHelper.getStringDateFromString(result, 2);
                }
                return result;
            }
        }
        return "";
    }

    private String getPriorityForTask(String userCommand) {
        String[] splits = userCommand.split(" ");
        for (int i = splits.length - 1; i >= 0; i--) {
            if (splits[i].equals(AppConst.KEY_WORD.PRIORITY)) {
            	if (mPosition == -1) {
                    mPosition = i;
                } else {
                    mPosition = Math.min(mPosition, i);
                }
                if (i == splits.length-1) { 
   					continue;
   				}
                if (splits[i+1].equals(AppConst.TASK_FIELD.HIGH) || splits[i+1].equals(AppConst.TASK_FIELD.LOW) || splits[i+1].equals(AppConst.TASK_FIELD.MEDIUM)) {
                    System.out.println(splits[i+1]);
                    return splits[i+1];
                } else if (!splits[i+1].equals(AppConst.KEY_WORD.TO) && !splits[i+1].equals(AppConst.KEY_WORD.FROM) && !splits[i+1].equals(AppConst.KEY_WORD.GROUP) && !splits[i+1].equals(AppConst.KEY_WORD.GRP) && !splits[i+1].equals(AppConst.KEY_WORD.BY) && !splits[i+1].equals(AppConst.KEY_WORD.BEFORE)) {
                	return null;
                }
            }
        }
        return "";
    }
    
    private String getStringDateForStartDate(String userCommand) {
    	String[] splits = userCommand.split(" ");
    	String result = "";
    	for (int i = 0; i < splits.length; i++) {
    		if (splits[i].equals(AppConst.KEY_WORD.FROM)) {
   				if (mPosition == -1) {
   					mPosition = i;
   				} else {
   					mPosition = Math.min(mPosition, i);
   				}
   				if (i == splits.length-1) { 
   					break;
   				}
   				for (int j = i+1; j < splits.length; j++) {
   					if (splits[j].equals(AppConst.KEY_WORD.TO) || splits[j].equals(AppConst.KEY_WORD.PRIORITY) || splits[j].equals(AppConst.KEY_WORD.GROUP) || splits[j].equals(AppConst.KEY_WORD.GRP) || splits[j].equals(AppConst.KEY_WORD.BY) || splits[j].equals(AppConst.KEY_WORD.BEFORE)) {
   						break;
   					} else {
   						if (j > i+1) {
   							result += " ";
   						}
   						result += splits[j];
   					}
   				}
				return result;
   			}
    	}
    	return "";
    }
    
    private String getStartDateForTask(String userCommand) {
   		String time = getStringDateForStartDate(userCommand);
	   	if (!time.equals("")) {
			time = mDateTimeHelper.getStringDateFromString(time, 1);
		}
		return time;
    }
    
    private String getEndDateForTask(String userCommand) {
   		String[] splits = userCommand.split(" ");
   		String time = "";
   		for (int i = splits.length - 1; i >= 0; i--) {
   			if (splits[i].equals(AppConst.KEY_WORD.TO)) {
   				if (mPosition == -1) {
   					mPosition = i;
   				} else {
   					mPosition = Math.min(mPosition, i);
   				}
   				if (i == splits.length-1) { 
   					continue;
   				}
   				for (int j = i + 1; j < splits.length; j++) {
   					if (splits[j].equals(AppConst.KEY_WORD.PRIORITY) || splits[j].equals(AppConst.KEY_WORD.GROUP) || splits[j].equals(AppConst.KEY_WORD.GRP) || splits[j].equals(AppConst.KEY_WORD.BY) || splits[j].equals(AppConst.KEY_WORD.BEFORE) || splits[j].equals(AppConst.KEY_WORD.FROM)) {
   						break;
   					} else {
   						if (j > i + 1) {
   							time += " ";
   						}
   						time += splits[j];
   					}
   				}
   				if (!time.equals("")) {
					time = mDateTimeHelper.getStringDateFromString(time, 2);
				}
				break;
   			}
   		}
   		return time;
    }

    private String getGroupForTask(String userCommand) {
        String[] splits = userCommand.split(" ");
        for (int i = splits.length - 1; i >= 0; i--) {
            if (splits[i].equals(AppConst.KEY_WORD.GRP) || splits[i].equals(AppConst.KEY_WORD.GROUP)) {
                if (mPosition == -1) {
   					mPosition = i;
   				} else {
   					mPosition = Math.min(mPosition, i);
   				}
   				if (i == splits.length-1) { 
   					continue;
   				}
                String result = "";
                for (int j = i + 1; j < splits.length; j++) {
                	if (splits[j].equals(AppConst.KEY_WORD.PRIORITY) || splits[j].equals(AppConst.KEY_WORD.BY) || splits[j].equals(AppConst.KEY_WORD.BEFORE) || splits[j].equals(AppConst.KEY_WORD.FROM) || splits[j].equals(AppConst.KEY_WORD.TO)) {
                		break;
                	}
                	if (j > i + 1) {
                		result += " ";
                	}
                	result += splits[j];
                }
                return result;
            }
        }
        return "";
    }

    private String getTaskInfo(String userCommand) {
        String[] splits = userCommand.split(" ");
        if (splits.length <= 1) {
        	return "";
        }
        if (mPosition == -1) {
            mPosition = splits.length;
        }
        String result = "";
        if (mPosition > 1 ) {
		    for (int i = 1; i < mPosition; i++) {
		        result += splits[i];
		        if (i != mPosition - 1) {
		            result += " ";
		        }
		    }
		}   
        return result;
    }

	private String getCommandType(String userCommand) {
        
        String[] splits = userCommand.split(" ");
        return splits[0];
    }
    
    
    
    private String getCommandSecondArgument(String userCommand) {
        
        String[] splits = userCommand.split(" ");
        if (splits.length > 1) {
        	return splits[1];
        }
        return "";  
    }

    private String getCommandArgument(String userCommand) {
    	String[] splits = userCommand.split(" ");
        String result = "";
        for (int i = 1; i < splits.length; i++) {
        	result += splits[i];
        	if (i != splits.length-1) {
        		result += " ";
        	}
       	}
       	return result;
    }
    
   	protected String getStartDateForTimetable(String userCommand) {
   	
   		String st = " " + userCommand + " ";
   		st = st.toLowerCase();
   		if (st.contains(AppConst.KEY_WORD.FROM1) && !st.contains(AppConst.KEY_WORD.TO1)) {
   			return null;
   		}
   		if (!st.contains(AppConst.KEY_WORD.FROM1) && st.contains(AppConst.KEY_WORD.TO1)) {
   			return null;
   		}
   		
		String[] commands = userCommand.toLowerCase().split(" ");
		String result = "";
		boolean isHasFrom = false;
		for (int i = 0; i < commands.length; i++) {
			if (commands[i].equals(AppConst.KEY_WORD.FROM)) {
				for (int j = i + 1; j < commands.length; j++) {
				
					if (commands[j].equals(AppConst.KEY_WORD.TO)) {
						break;	
					}
					result += " " + commands[j];
				}
				isHasFrom = true;
				break;
			}
		}
		if (!isHasFrom) {
			for (int i = 1; i < commands.length; i++) {
				result += " " + commands[i];
			}
		}
		if (result.equals("")) {
			result = AppConst.DATE_TIME.THIS_MON;
		}
		
		result = mDateTimeHelper.getDateMonthFromString(result, 1);
		return result;
	}
	
	protected String getEndDateForTimetable(String userCommand) {
	
		String st = " " + userCommand + " ";
   		st = st.toLowerCase();
   		if (st.contains(AppConst.KEY_WORD.FROM1) && !st.contains(AppConst.KEY_WORD.TO1)) {
   			return null;
   		}
   		if (!st.contains(AppConst.KEY_WORD.FROM1) && st.contains(AppConst.KEY_WORD.TO1)) {
   			return null;
   		}
	
		String[] commands = userCommand.toLowerCase().split(" ");
		String result = "";
		boolean isHasTo = false;
		for (int i = 0; i < commands.length; i++) {
			if (commands[i].equals(AppConst.KEY_WORD.TO)) {
				for (int j = i + 1; j < commands.length; j++) {
					result += " " + commands[j];
				}
				isHasTo = true;
				break;
			}
		}
		if (!isHasTo) {
			for (int i = 1; i < commands.length; i++) {
				result += " " + commands[i];
			}
		}
		
		if (result.equals("")) {
			result = AppConst.DATE_TIME.THIS_SUN;
		}
		result = mDateTimeHelper.getDateMonthFromString(result, 2);
		return result;
	}
	
	
	private int getNumberFromString(String st, int pos) {
		int number = 0;
		for (int i = pos; i < st.length(); i++) {
			if (st.charAt(i) < '0' || st.charAt(i) > '9') {
				break;
			}
			number = number * 10 + (st.charAt(i) - '0');
		}
		return number;
	}
	
	private boolean isNumber(String st) {
		if (st == null || st.length() == 0) {
			return false;
		}
		for (int i = 0; i < st.length(); i++) {
			if (st.charAt(i) < '0' || st.charAt(i) > '9') {
				return false;
			}
		}
		return true;
	}
	
	protected ArrayList<Integer> getListOfId(String id) {
		String[] ids = id.split(" ");
		id = "";
		for (int i = 0; i < ids.length; i++) {
			if (i > 0) {
				if (isNumber(ids[i]) && isNumber(ids[i - 1])) {
					id += " ";
				} else if (isNumber(ids[i-1]) && ids[i].charAt(0) >= '0' && ids[i].charAt(i) <= '9') {
					id += " ";
				}
			}
			id += ids[i];
		}
		id += " ";
		ArrayList<Integer> result = new ArrayList<Integer>();
		int pos = -1, i = 0;
		while (i < id.length()) {
			if (id.charAt(i) >= '0' && id.charAt(i) <= '9') {
				if (pos == -1) {
					pos = i;
				}
				i++;
			} else if (id.charAt(i) == '-') {
				if (pos != -1) {
					int start = getNumberFromString(id, pos);
					int end = getNumberFromString(id, i + 1);
					if (start <= end && start != 0) {
						for (int j = start; j <= end; j++) {
							result.add(j);
						}
					} else {
						return null;
					}
					i++;  pos = -1;
					while (i < id.length()) {
						if (id.charAt(i) < '0' || id.charAt(i) > '9') {
							break;
						}
						i++;
					}
				} else {
					return null;
				}
			} else if (id.charAt(i) == '.' && i < id.length()-1 && id.charAt(i + 1) == '.') {
				i++;
				if (pos != -1) {
					int start = getNumberFromString(id, pos);
					int end = getNumberFromString(id, i + 1);
					if (start <= end && start != 0) {
						for (int j = start; j <= end; j++) {
							result.add(j);
						}
					} else {
						return null;
					}
					i++	;  pos = -1;
					while (i < id.length()) {
						if (id.charAt(i) < '0' || id.charAt(i) > '9') {
							break;
						}
						i++;
					}
				} else {
					return null;
				}
			} else if (id.charAt(i) == '.' || id.charAt(i) == ',' || id.charAt(i) == ' ') {
				if (pos != -1) {
					result.add(getNumberFromString(id, pos));
				}
				i++;  pos = -1;
			} else {
				return null;	
			}
		}
		return result;
	}

}
```
###### DateTimeHelper.java
``` java
package cs2103;
import java.util.*;
import java.text.SimpleDateFormat;
import java.text.ParseException;
	

public class DateTimeHelper {
	
	
	private static SimpleDateFormat mStandardTimeFormat = new SimpleDateFormat("dd/MM HH:mm");
	private static SimpleDateFormat mDisplayDateTimeFormat = new SimpleDateFormat("dd MMM HH:mm");
	
	private static int[] mDaysInMonth = AppConst.DATE_TIME.NUMBER_DAYS_IN_MONTH;
	
	private static final String[] mMonths = AppConst.DATE_TIME.MONTH_NAMES;
	private static final String[] mDays = AppConst.DATE_TIME.DAY_IN_WEEK;
										
	
	public DateTimeHelper() {
	
	}
	
	protected boolean isCorrectDate(String dateTime) {
		if (dateTime == null || dateTime.equals("")) {
			return true;
		}
		
		int day = getDayFromStringDate(dateTime);
		int month = getMonthFromStringDate(dateTime);
		if (day <= 0 || month <= 0 || month > AppConst.DATE_TIME.NUMBER_MONTHS) {
			return false;
		}
		if (day > mDaysInMonth[month - 1]) {
			return false;
		}
		return true;
	}
	
	// string 'date' should have format dd/MM HH:mm or dd/MM
	// get first 2 characters for date
	protected int getDayFromStringDate(String date) {
		String day = String.valueOf(date.charAt(0)) + String.valueOf(date.charAt(1));
		return Integer.parseInt(day);
	}
	
	// string 'date' should have format dd/MM HH:mm or dd/MM
	// get character index 3 and 4 for month
	protected int getMonthFromStringDate(String date) {
		String month = String.valueOf(date.charAt(3)) + String.valueOf(date.charAt(4));
		return Integer.parseInt(month);
	}
	
	// string 'date' should have format dd/MM HH:mm or dd/MM
	protected int getHourFromStringDate(String date) {
		int position = 0;
		for (int i = date.length() - 1; i >= 0; i--) {
			if (date.charAt(i) == AppConst.DATE_TIME.COLON.charAt(0)) {
				position = i; break;
			}
		}
		if (position == 0) {
			return 0;
		}
		String hour = String.valueOf(date.charAt(position-2)) + String.valueOf(date.charAt(position-1));
		return Integer.parseInt(hour);
	}
	
	// string 'date' should have format dd/MM HH:mm or dd/MM
	protected int getMinuteFromStringDate(String date) {
		int position = 0;
		for (int i = date.length() - 1; i >= 0; i--) {
			if (date.charAt(i) == AppConst.DATE_TIME.COLON.charAt(0)) {
				position = i; break;
			}
		}
		if (position == 0) {
			return 0;
		}
		String minute = String.valueOf(date.charAt(position+1)) + String.valueOf(date.charAt(position+2));
		return Integer.parseInt(minute);
	}
	
	protected boolean isToday(String dateTime) {
		int day = getDayFromStringDate(dateTime);
		int month = getMonthFromStringDate(dateTime);
		String date = getCurrentTimeString();
		int currentDay = getDayFromStringDate(date);
		int currentMonth = getMonthFromStringDate(date);
		if (day == currentDay && month == currentMonth) {
			return true;
		}
		return false;
	}
	
	protected boolean isYesterday(String dateTime) {
		int day = getDayFromStringDate(dateTime);
		int month = getMonthFromStringDate(dateTime);
		int yesterdayDay = getDayFromStringDate(getYesterday());
		int yesterdayMonth = getMonthFromStringDate(getYesterday());
		if (day == yesterdayDay && month == yesterdayMonth) {
			return true;
		}
		return false;
	}
	
	protected boolean isTomorrow(String dateTime) {
		int day = getDayFromStringDate(dateTime);
		int month = getMonthFromStringDate(dateTime);
		int tomorrowDay = getDayFromStringDate(getTomorrow());
		int tomorrowMonth = getMonthFromStringDate(getTomorrow());
		if (day == tomorrowDay && month == tomorrowMonth) {
			return true;
		}
		return false;
	}
	
	protected String getYesterday() {
		String dateTime = getCurrentTimeString();
		int day = getDayFromStringDate(dateTime);
		int month = getMonthFromStringDate(dateTime);
		day--;
		if (day == 0 && month != 1) {
			month--;  day = mDaysInMonth[month - 1];		
		} 
		if (month > 0 && month < 13 && day > 0 && day <= mDaysInMonth[month - 1]) {
			String dayString = String.valueOf(day);
			String monthString = String.valueOf(month);
			if (dayString.length() < 2) {
				dayString = AppConst.DATE_TIME.ZERO + dayString;
			}
			if (monthString.length() < 2) {
				monthString = AppConst.DATE_TIME.ZERO + monthString;
			}
			return dayString + AppConst.DATE_TIME.SLASH + monthString;
		}
		return "";
	}
	
	protected String getToday() {
		String dateTime = getCurrentTimeString();
		int day = getDayFromStringDate(dateTime);
		String dayString = String.valueOf(day);
		if (dayString.length() < 2) {
			dayString = AppConst.DATE_TIME.ZERO + dayString;
		}
		int month = getMonthFromStringDate(dateTime);
		String monthString = String.valueOf(month);
		if (monthString.length() < 2) {
			monthString = AppConst.DATE_TIME.ZERO + monthString;
		}
		return dayString + AppConst.DATE_TIME.SLASH + monthString;
	}
	
	protected String getTomorrow() {
		String dateTime = getCurrentTimeString();
		int day = getDayFromStringDate(dateTime);
		int month = getMonthFromStringDate(dateTime);
		day++;
		if (day > mDaysInMonth[month - 1]) {
			day = 1; month++;
		}
		if (month > 0 && month < 13 && day > 0 && day <= mDaysInMonth[month - 1]) {
			String dayString = String.valueOf(day);
			String monthString = String.valueOf(month);
			if (dayString.length() < 2) {
				dayString = AppConst.DATE_TIME.ZERO + dayString;
			}
			if (monthString.length() < 2) {
				monthString = AppConst.DATE_TIME.ZERO + monthString;
			}
			return dayString + AppConst.DATE_TIME.SLASH + monthString;
		}
		return "";
	}
	
	
	// saved string date time with format dd/MM HH:mm
	// but display date time with format dd MMM HH:mm
	protected String convertToDisplayFormat(String dateTime) {
		if (dateTime == null || dateTime.equals("")) {
			return dateTime;
		}
		dateTime = dateTime.toLowerCase();
		Date date = convertStringToDate(dateTime);
		if (date == null) {
			return dateTime;
		}
		SimpleDateFormat timeFormat = new SimpleDateFormat(AppConst.DATE_TIME.TIME_FORMAT);
		String time = " " + timeFormat.format(date);
		
		if (isYesterday(dateTime)) {
			return AppConst.DATE_TIME.YESTERDAY + time;
		}
		
		if (isToday(dateTime)) {
			return AppConst.DATE_TIME.TODAY + time;
		}
		if (isTomorrow(dateTime)) {
			return AppConst.DATE_TIME.TOMORROW + time;
		}
		
		return mDisplayDateTimeFormat.format(date);			 
	}
	
	
	protected String convertDateMonthToDisplayFormat(String dateTime) {
		
		SimpleDateFormat dateFormat = new SimpleDateFormat(AppConst.DATE_TIME.DISPLAY_DATE_FORMAT);
		if (dateTime == null || dateTime.equals("")) {
			return dateTime;
		}
		
		dateTime = dateTime.toLowerCase();
		Date date = convertStringToDate(dateTime);
		if (date == null) {
			return dateTime;
		}
		
		if (isYesterday(dateTime)) {
			return AppConst.DATE_TIME.YESTERDAY;
		}
		
		if (isToday(dateTime)) {
			return AppConst.DATE_TIME.TODAY;
		}
		if (isTomorrow(dateTime)) {
			return AppConst.DATE_TIME.TOMORROW;
		}
		
		return dateFormat.format(date);
	}
	
	protected String getCurrentTimeString() {
		return mStandardTimeFormat.format(new Date());
	}
	
	protected Date getCurrentDate() {
		return new Date();
	}
	
	protected Date convertStringToDate(String dateTime) {
		try {
			return mStandardTimeFormat.parse(dateTime);
		} catch (ParseException pe) {
			return null;	
		}
	}
	
	protected String convertDateToString(Date dateTime) {
		return mStandardTimeFormat.format(dateTime);
	}
	
	protected int compareDates(Date date1, Date date2) {
		if (date1 == null) {
			return -1;
		}
		if (date2 == null) {
			return 1;
		}
		return date1.compareTo(date2);
	}
	
	protected int compareStringDates(String stringDate1, String stringDate2) {
	
		Date date1 = convertStringToDate(stringDate1);
		Date date2 = convertStringToDate(stringDate2);
		return compareDates(date1, date2);	
	}


	// to get time, use this function to get minutes
	protected String getMinutesFromString(String time) {
		
		int leng = time.length();
		if (leng <= 2) {
			return AppConst.DATE_TIME.DOUBLE_ZERO;
		}
		String minute = String.valueOf(time.charAt(leng-2)) + String.valueOf(time.charAt(leng - 1));
		if (!isNumber(minute)) {
			return null;
		}
		int x = Integer.parseInt(minute);
		if (x >= AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR) {
			return null;
		}
		minute = String.valueOf(x);
		if (minute.length() < 2) {
			minute = AppConst.DATE_TIME.ZERO + minute;
		}
		return minute;
	}
	
	
	// to get time, use this function to get hour
	protected String getHoursFromString(String time, int flag) {

		if (time.length() <= 2) {
			if (!isNumber(time)) {
				return null;
			}
			if (flag == 2) {
				int x = Integer.parseInt(time);
				if (x < AppConst.DATE_TIME.NUMBER_AM) {
					x += AppConst.DATE_TIME.NUMBER_AM;
				}
				time = String.valueOf(x);
			}
			if (time.length() < 2) {
				time = AppConst.DATE_TIME.ZERO + time;
			}
			return time;
		}
		String hour = "";
		for (int i = 0; i < time.length()-2; i++) {
			if (time.charAt(i)<'0' || time.charAt(i)>'9') {
				break;
			}
			hour += String.valueOf(time.charAt(i));
		}
		if (hour.equals("")) {
			return "";
		}
		int x = Integer.parseInt(hour);
		if (flag == 2) {
			if (x < AppConst.DATE_TIME.NUMBER_AM) {
				x += AppConst.DATE_TIME.NUMBER_AM;
			}
		}
		if (x >= AppConst.DATE_TIME.NUMBER_HOURS_PER_DAY) {
			return null;
		}
		
		hour = String.valueOf(x);
		if (hour.length() < 2) {
			hour = AppConst.DATE_TIME.ZERO + hour;
		}		
		return hour;
	}
	
	protected boolean isNumber(String st) {
		for (int i = 0; i < st.length(); i++) {
			if (st.charAt(i)<'0' || st.charAt(i)>'9') {
				return false;
			}
		}
		return true;
	}


	// get time from a string of date and time
	// flag = 1: if no time found, default 00:00
	// flag = 2: if no time found, default 23:59
	protected String getTimeFromString(String dateTime, int flag) {
		String time = "";
		if (flag == 1) {
			time = AppConst.DATE_TIME.START_TIME;
		} else if (flag == 2) {
			time = AppConst.DATE_TIME.END_TIME;
		}
		
		String[] splits = dateTime.split(" ");
		
		String hour = "";
		String minute = "";
		int x = 1;
		
		if (splits.length == 0) {
			return time;
		}
		dateTime = dateTime.toLowerCase();
		splits = dateTime.split(" ");
		
		int count = 0;
		
		for (int i = splits.length-1; i >= 0; i--) {
		
			if (splits[i].endsWith(AppConst.DATE_TIME.AM) || splits[i].endsWith(AppConst.DATE_TIME.PM)) {
				if (splits[i].endsWith(AppConst.DATE_TIME.PM)) {
					x = 2;
				}
				if (splits[i].equals(AppConst.DATE_TIME.AM) || splits[i].equals(AppConst.DATE_TIME.PM)) {
					if (i > 0) {
						hour = getHoursFromString(splits[i-1], x);
						minute = getMinutesFromString(splits[i-1]);
					}
					count++;
					continue;
				} else {
					String st = splits[i].substring(0, splits[i].length()-2);
					hour = getHoursFromString(st, x);
					minute = getMinutesFromString(st);
					count++;
					continue;
				}
			}
			if (splits[i].contains(".") || splits[i].contains(":")) {
				hour = getHoursFromString(splits[i], x);
				minute = getMinutesFromString(splits[i]);
				count++;
				continue;
			}
			if (splits[i].length() > 2 && isNumber(splits[i])) {
				hour = getHoursFromString(splits[i], x);
				minute = getMinutesFromString(splits[i]);
				count++;
				continue;
			}
			
		}
		
		if (count > 1) {
			return null;
		}
		if (count == 0) {
			return time;
		}
		
		if (hour != null && minute != null) {
			if (hour.equals("") || minute.equals("")) {
				return time;
			}
			if (hour.length()<2) {
				hour = AppConst.DATE_TIME.ZERO + hour;
			}
			if (minute.length()<2) {
				minute = AppConst.DATE_TIME.ZERO + minute;
			}
			return hour + AppConst.DATE_TIME.COLON + minute;
		}
		return null;
	}
	
	// return 1->12 for month matched
	// return 0 if no matched found
	protected int getMonthMatched(String st) {
	
		st = st.toLowerCase();
		if (st == null || st.equals("")) {
			return 0;
		}
		for (int i = 0; i < mMonths.length; i++) {
			int j = 0, k = 0;
			String st1 = mMonths[i];
			if (st1.charAt(0) != st.charAt(0)) {
				continue;
			}
			while (j < st.length() && k < st1.length()) {
				while (k < st1.length() && st1.charAt(k) != st.charAt(j)) {
					k++;
				}
				if (k >= st1.length()) {
					break;
				}
				k++;  j++;
			}
			if (j >= st.length()) {
				return i+1;
			}
		}
		return 0;
	}
	
	// This is to get month in characters, like Oct, Sep
	protected String getMonthFromString(String dateTime) {
		
		String[] splits = dateTime.split(" ");
		if (splits.length == 0) {
			return "";
		}
		dateTime = dateTime.toLowerCase();
		splits = dateTime.split(" ");
		int count = 0, res = 0;
		for (int i = 0; i < splits.length; i++) {
			int x = getMonthMatched(splits[i]);
			if (x > 0) {
				count++;
				res = x;
			}
		}
		if (count>1) {
			// More than 1 matched Month format
			return null;
		} else if (count == 1) {
			String result = String.valueOf(res);
			if (result.length() < 2) {
				result = AppConst.DATE_TIME.ZERO + result;
			}
			return result;
		}	
		return "";
	}
	
	// get month in a string of date and month,
	// get month for number, for example: 30/12
	protected String getMonth(String st) {
		String month = "";
		if (st.length()<3) {
			return null;
		}
		
		st = st.toLowerCase();
		
		for (int i = st.length()-1; i >= 0; i--) {
			if (st.charAt(i) < '0' || st.charAt(i) > '9') {
				break;
			}
			month = String.valueOf(st.charAt(i)) + month;
		}
		if (month.equals("")) {
			return null;
		}
		int x = Integer.parseInt(month);
		if (x > AppConst.DATE_TIME.NUMBER_MONTHS) {
			return null;
		}
		if (month.length() < 2) {
			month = AppConst.DATE_TIME.ZERO + month;
		}
		return month;
	}
	
	// get date in a string date month
	protected String getDate(String st) {
		String date = "";
		for (int i = 0; i < st.length(); i++) {
			if (st.charAt(i) < '0' || st.charAt(i) > '9') {
				if (i < st.length()-3) {
					return null;
				}
				break;
			}
			date += st.charAt(i);
		}
		if (date.equals("")) {
			return null;
		}
		int x = Integer.parseInt(date);
		if (x > AppConst.DATE_TIME.MAX_NUMBER_DAYS_PER_MONTH || x <= 0) {
			return null;
		}
		if (date.length() < 2) {
			date = AppConst.DATE_TIME.ZERO + date;
		}
		return date;
		
	}
	
	// 0->6: Mon->Sun, -1: not matched
	protected int getMatchedDayInWeek(String day) {
		if (day == null || day.length()<2) {
			return -1;
		}
		day = day.toLowerCase();
		for (int i = 0; i < AppConst.DATE_TIME.NUMBER_DAYS_PER_WEEK; i++) {
			if (mDays[i].startsWith(day)) {
				return i;
			}
		}
		return -1;
	}
	
	
	// Used 1/1/2015 is Thursday to compute day in week of a date
	protected int getDayInWeekForDate(String date) {
		int day = getDayFromStringDate(date);
		int month = getMonthFromStringDate(date);
		int number = 0;
		for (int i = 1; i < month; i++) {
			number += mDaysInMonth[i-1];
		}
		number += day;
		number += 3;
		// 1/1/2015 is Thursday, we go back to Monday is 29/12/2014
		number = number % AppConst.DATE_TIME.NUMBER_DAYS_PER_WEEK;
		if (number == 0) {
			number = AppConst.DATE_TIME.NUMBER_DAYS_PER_WEEK;
		}
		return number - 1;
		
	}
	
	
	// Return day in week (Mon-Sun) for a string of date time format dd/MM HH:mm
	protected String getStringDayInWeekForDate(String date) {
		if (date == null || date.equals("")) {
			return null;
		}
		int dayInWeek = getDayInWeekForDate(date);
		String result = mDays[dayInWeek];
		return String.valueOf(result.charAt(0)).toUpperCase() + String.valueOf(result.charAt(1)) + String.valueOf(result.charAt(2));
	}
	
	protected String getDateAfterSomeDaysFromNow(int number) {
		String currentDateTime = getCurrentTimeString();
		int day = getDayFromStringDate(currentDateTime);
		int month = getMonthFromStringDate(currentDateTime);
		day += number;
		while (month < AppConst.DATE_TIME.NUMBER_MONTHS && day > mDaysInMonth[month-1]) {
			day -= mDaysInMonth[month-1];
			month++;
		}
		
		if (month > 0 && month <= AppConst.DATE_TIME.NUMBER_MONTHS && day > 0 && day <= mDaysInMonth[month-1]) {
		
			String dayString = String.valueOf(day);
			if (dayString.length() < 2) {
				dayString = AppConst.DATE_TIME.ZERO + dayString;
			}
			String monthString = String.valueOf(month);
			if (monthString.length() < 2) {
				monthString = AppConst.DATE_TIME.ZERO + monthString;
			}
			return dayString + AppConst.DATE_TIME.SLASH + monthString;
		}
		return null;
	}
	
	protected String getDateBeforeSomeDaysFromNow(int number) {
		String currentDateTime = getCurrentTimeString();
		int day = getDayFromStringDate(currentDateTime);
		int month = getMonthFromStringDate(currentDateTime);
		day -= number;
		while (month > 1 && day <= 0) {
			month--;
			day += mDaysInMonth[month-1];
		}
		if (month > 0 && month <= AppConst.DATE_TIME.NUMBER_MONTHS && day > 0 && day <= mDaysInMonth[month-1]) {
			String dayString = String.valueOf(day);
			if (dayString.length() < 2) {
				dayString = AppConst.DATE_TIME.ZERO + dayString;
			}
			String monthString = String.valueOf(month);
			if (monthString.length() < 2) {
				monthString = AppConst.DATE_TIME.ZERO + monthString;
			
			}
			return day + AppConst.DATE_TIME.SLASH + month;
		}	
		return null;
	}
	
	// day_ is a day in a week, like Mon, Tues, ..
	// this function is to get date for the day_ in current week
	// for example: today is Fri 30/10, if day_ = Thus -> return 29/10
	
	protected String getDateFromDayInCurrentWeek(String day_) {
		day_ = day_.toLowerCase();
		int dayInWeek = getMatchedDayInWeek(day_);
		if (dayInWeek == -1) {
			return null;
		}
		
		String currentDateTime = getCurrentTimeString();

		int currentDayInWeek = getDayInWeekForDate(currentDateTime);
		int day = getDayFromStringDate(currentDateTime);
		int month = getMonthFromStringDate(currentDateTime);
		
		if (dayInWeek > currentDayInWeek) { 			
			day += dayInWeek - currentDayInWeek;
			if (day > mDaysInMonth[month-1]) {
				day -= mDaysInMonth[month-1];
				month++;
			}
		} else {
			day += dayInWeek - currentDayInWeek;
			if (day <= 0 && month > 1) {
				month--;
				day += mDaysInMonth[month-1];
			}
		}
		
		if (month > 0 && month <= AppConst.DATE_TIME.NUMBER_MONTHS && day > 0 && day <= mDaysInMonth[month-1]) {
			String dayString = String.valueOf(day);
			if (dayString.length() < 2) {
				dayString = AppConst.DATE_TIME.ZERO + dayString;
			}
			String monthString = String.valueOf(month);
			if (monthString.length() < 2) {
				monthString = AppConst.DATE_TIME.ZERO + monthString;
			
			}
			return dayString + AppConst.DATE_TIME.SLASH + monthString;
		}
		
		return null;
	}
	
	// This function to get date month from a date time string user typed
	// supported multiple kinds of date time format
	// for example: 30/12, 30 of Dec, this Fri, next Fri, Fri next 2 weeks,
	// next 2 days, next 2 weeks ...
	
	protected String getDateMonthFromString(String dateTime, int flag) {
		
		dateTime = dateTime.toLowerCase();

		if (dateTime.equals(AppConst.DATE_TIME.NOW)) {
			String result = getCurrentTimeString();
			return result.substring(0, 5);
		}

		String month = getMonthFromString(dateTime);
		String date = "";
		if (month == null) {
			return null;
		}
		
		String[] splits = dateTime.split(" ");
		
		int count = 0;
		String result = null;
		int numberResult = 0;
		
		if (!month.equals("")) {
			for (int i = 0; i < splits.length; i++) {
				String st = splits[i];
				if (st.endsWith(AppConst.DATE_TIME.TH) || st.endsWith(AppConst.DATE_TIME.ST) || st.endsWith(AppConst.DATE_TIME.RD) || st.endsWith(AppConst.DATE_TIME.ND) || (st.length() < 3 && isNumber(st))) {
					date = getDate(st);
					if (date != null && !date.equals("")) {
						count++;
					}
				} 
			}
			if (count > 1 || count == 0) {
				return null;
			}
			if (date.length() < 2) {
				date = AppConst.DATE_TIME.ZERO + date;
			}
			
			if (month.length() < 2) {
				month = AppConst.DATE_TIME.ZERO + month;
			}
			result = date + AppConst.DATE_TIME.SLASH + month;
			numberResult = 1;
			
		}
		
		count = 0;
		
		for (int i = 0; i < splits.length; i++) {
			String st = splits[i];
			if (st.contains(AppConst.DATE_TIME.SLASH) || st.contains("-")) {
				month = getMonth(st);
				date = getDate(st);
				if (month != null && date != null && !month.equals("") && !date.equals("")) {
					count++;
				}
			}	
		}
		if (count > 1) {
			return null;
		} else if (count == 1){
			if (numberResult > 0) {
				return null;
			}
			numberResult = 1;
			
			if (date.length() < 2) {
				date = AppConst.DATE_TIME.ZERO + date;
			}
			
			if (month.length() < 2) {
				month = AppConst.DATE_TIME.ZERO + month;
			}
			result = date + AppConst.DATE_TIME.SLASH + month;
		}
		
		for (int i = 0; i < splits.length; i++) {
			if (splits[i].equals(AppConst.DATE_TIME.YESTERDAY.toLowerCase()) || splits[i].equals(AppConst.DATE_TIME.YTD)) {
				if (numberResult > 0) {
					return null;
				}
				numberResult = 1;
				result = getYesterday();
			}
			
			if (splits[i].equals(AppConst.DATE_TIME.TODAY.toLowerCase())) {
				if (numberResult > 0) {
					return null;
				}
				numberResult = 1;
				result = getToday();
			}
			
			if (splits[i].equals(AppConst.DATE_TIME.TOMORROW.toLowerCase()) || splits[i].equals(AppConst.DATE_TIME.TMR)) {
				if (numberResult > 0) {
					return null;
				}
				numberResult = 1;
				result = getTomorrow();
			}
		}
		
		int dayInWeek = -1;
		count = 0;
		for (int i = 0; i < splits.length; i++) {
			int x = getMatchedDayInWeek(splits[i]);
			if (x != -1) {
				count++;  dayInWeek = x;
			}
		}
		if (count > 1) {
			return null;
		}
		
		count = 0;
		
		int daysFromNow = 0;
		int weeksFromNow = 0;	
		
		for (int i = 0; i < splits.length; i++) {
			if (splits[i].equals(AppConst.DATE_TIME.THIS) || splits[i].equals(AppConst.DATE_TIME.NEXT) || splits[i].equals(AppConst.DATE_TIME.NXT) || splits[i].equals(AppConst.DATE_TIME.LAST)) {
				count++;
			}
		}
		if (count > 1) {
			return null;
		}
		
		count = 0;
		
		for (int i = 0; i < splits.length; i++) {
			if (splits[i].equals(AppConst.DATE_TIME.NEXT) || splits[i].equals(AppConst.DATE_TIME.NXT)) {
				if (i >= splits.length - 1) {
					break;
				}
				if (isNumber(splits[i+1])) {
					if (i >= splits.length - 2) {
						continue;
					}
					String st = splits[i+2];
					if (st.equals(AppConst.DATE_TIME.DAY) || st.equals(AppConst.DATE_TIME.DAYS)) {
						daysFromNow = Integer.parseInt(splits[i+1]);
						count++;
						continue;
					}
					if (st.equals(AppConst.DATE_TIME.WEEK) || st.equals(AppConst.DATE_TIME.WEEKS)) {
						weeksFromNow = Integer.parseInt(splits[i+1]);
						count++;
						continue;
					}
				} else if (splits[i+1].equals(AppConst.DATE_TIME.DAY) || splits[i+1].equals(AppConst.DATE_TIME.DAYS)) {
					daysFromNow = 1;
					count++;
					continue;
				} else if (splits[i+1].equals(AppConst.DATE_TIME.WEEK) || splits[i+1].equals(AppConst.DATE_TIME.WEEKS)) {
					weeksFromNow = 1;
					count++;
					continue;
				} else if (getMatchedDayInWeek(splits[i+1])>=0) {
					weeksFromNow = 1;
					continue;
				}
			}
			
			if (splits[i].equals(AppConst.DATE_TIME.LAST)) {
				if (i >= splits.length - 1) {
					break;
				}
				if (isNumber(splits[i+1])) {
					if (i >= splits.length - 2) {
						continue;
					}
					String st = splits[i+2];
					if (st.equals(AppConst.DATE_TIME.DAY) || st.equals(AppConst.DATE_TIME.DAYS)) {
						daysFromNow = -Integer.parseInt(splits[i+1]);
						count++;
						continue;
					}
					if (st.equals(AppConst.DATE_TIME.WEEK) || st.equals(AppConst.DATE_TIME.WEEKS)) {
						weeksFromNow = -Integer.parseInt(splits[i+1]);
						count++;
						continue;
					}
				} else if (splits[i+1].equals(AppConst.DATE_TIME.DAY) || splits[i+1].equals(AppConst.DATE_TIME.DAYS)) {
					daysFromNow = -1;
					count++;
					continue;
				} else if (splits[i+1].equals(AppConst.DATE_TIME.WEEK) || splits[i+1].equals(AppConst.DATE_TIME.WEEKS)) {
					weeksFromNow = -1;
					count++;
					continue;
				} else if (getMatchedDayInWeek(splits[i+1])>=0) {
					weeksFromNow = -1;
					continue;
				}
			}			
		}
		
		if (count > 1) {
			return null;
		}
		if (count == 1 && numberResult > 0) {
			return null;
		}
		
		for (int i = 0; i < splits.length; i++) {
			if (splits[i].equals(AppConst.DATE_TIME.THIS)) {
				if (i == splits.length - 1) {
					break;
				}
				if (getMatchedDayInWeek(splits[i+1])>=0) {
					count++;
					continue;
				}
				if (splits[i+1].equals(AppConst.DATE_TIME.WEEK) || splits[i+1].equals(AppConst.DATE_TIME.WEEKS)) {
					count++;
					continue;
				}
			}
		}
		
		if (count > 1) {
			return null;
		}
		
		if (count == 0 && dayInWeek != -1) {
			count++;
		} else if (dayInWeek == -1 && daysFromNow == 0) {
			if (flag == 1) {
				dayInWeek = 0;
			} else {
				dayInWeek = 6;
			}

		}
		
		if (count == 1 && numberResult > 0) {
			return null;
		}
		
		if (count == 0) {
			return result;
		}
		
		if (daysFromNow != 0) {
			if (daysFromNow > 0) {
				return getDateAfterSomeDaysFromNow(daysFromNow);
			} else {
				return getDateBeforeSomeDaysFromNow(daysFromNow);
			}
		}
		
		// get the date for dayInWeek for this current week
		String dateForDayInWeek = getDateFromDayInCurrentWeek(mDays[dayInWeek]);
		int day_ = getDayFromStringDate(dateForDayInWeek);
		int month_ = getMonthFromStringDate(dateForDayInWeek);
		int numberOfDays = weeksFromNow * AppConst.DATE_TIME.NUMBER_DAYS_PER_WEEK;
		if (numberOfDays > 0) {
			day_ += numberOfDays;
			while (month_ <= AppConst.DATE_TIME.NUMBER_MONTHS && day_ > mDaysInMonth[month_-1]) {
				day_ -= mDaysInMonth[month_-1];
				month_++;
			}
		} else if (numberOfDays > 0) {
			day_ -= numberOfDays;
			while (day_ <= 0 && month_ > 1) {
				month_--;
				day_ += mDaysInMonth[month_-1];
			}
		}
		
		if (month_ > 0 && month_ <= AppConst.DATE_TIME.NUMBER_MONTHS && day_ > 0 && day_ <= mDaysInMonth[month_-1]) {
			
			String dayString = String.valueOf(day_);
			if (dayString.length() < 2) {
				dayString = AppConst.DATE_TIME.ZERO + dayString;
			}
			String monthString = String.valueOf(month_);
			if (monthString.length() < 2) {
				monthString = AppConst.DATE_TIME.ZERO + monthString;
			}
			
			return dayString + AppConst.DATE_TIME.SLASH + monthString;
		}
		
		return null;
	}


	// This main function to get date and time from user command
	// flag = 1 means this is the 'from' date time,
	// we use 00:00 for time if there is no time
	// we use Mon for date if only have week and no specific date
	// flag = 2 means this is the 'to' or 'deadline' date time,
	// we use 23:59 for time, Sun for date
	protected String getStringDateFromString(String dateTime, int flag) {
		
		dateTime = dateTime.toLowerCase();
		
		if (dateTime.equals(AppConst.DATE_TIME.NOW)) {
			return getCurrentTimeString();
		}
		
		String time = getTimeFromString(dateTime, flag);
		String date = getDateMonthFromString(dateTime, flag);
		if (time == null || date == null) {
			return null;
		}
				
		if (date.equals("")) {
			return null;
		}
		
		return date + " " + time;
	}

	// have a date time with format: dd/MM HH:mm
	// get MM from this string
	protected String getMonthStringForDateTime(String dateTime) {
		String month = String.valueOf(dateTime.charAt(3)) + String.valueOf(dateTime.charAt(4));
		int x = Integer.parseInt(month);
		return mMonths[x-1];
	}
	
	
	// To get how many days from 1/1/2015 to day/month/2015
	protected int getNumberOfDayFromThisYearForDate(int day, int month) {
		int result = 0;
		for (int i = 1; i < month; i++) {
			result += mDaysInMonth[i-1];
		}
		result += day;
		return result;
	}
	
	// To get date for numberOfDays from 1/1/2015
	protected String getDateForNumberOfDays(int numberOfDays) {
		int month = 1, day = numberOfDays;
		while (month <= 12) {
			if (day <= mDaysInMonth[month-1]) {
				break;
			}
			day -= mDaysInMonth[month-1];
			month++;
		}
		if (day == 0) {
			return AppConst.DATE_TIME.START_DATE;
		}
		if (month > 12) {
			return AppConst.DATE_TIME.END_DATE;
		}
		String dayString = String.valueOf(day);
		if (dayString.length() < 2) {
			dayString = AppConst.DATE_TIME.ZERO + dayString;
		}
		String monthString = String.valueOf(month);
		if (monthString.length() < 2) {
			monthString = AppConst.DATE_TIME.ZERO + monthString;
		}
		return dayString + AppConst.DATE_TIME.SLASH + monthString;
	}
	
	// period has format: HH:mm HH:mm
	// start time will be first HH:mm
	protected int getStartTimeFromStringPeriod(String period) {
		String hour = String.valueOf(period.charAt(0)) + String.valueOf(period.charAt(1));
		String minute = String.valueOf(period.charAt(3)) + String.valueOf(period.charAt(4));
		return Integer.parseInt(hour) * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR + Integer.parseInt(minute);
	}
	
	// period has format: HH:mm HH:mm
	// start time will be first HH:mm
	protected String getStringStartTimeForStringPeriod(String period) {
		String hour = String.valueOf(period.charAt(0)) + String.valueOf(period.charAt(1));
		String minute = String.valueOf(period.charAt(3)) + String.valueOf(period.charAt(4));
		return hour + AppConst.DATE_TIME.COLON + minute;
	}
	
	// period has format: HH:mm HH:mm
	// end time will be second HH:mm
	protected int getEndTimeFromStringPeriod(String period) {
		int length = period.length();
		String hour = String.valueOf(period.charAt(length-5)) + String.valueOf(period.charAt(length-4));
		String minute = String.valueOf(period.charAt(length-2)) + String.valueOf(period.charAt(length-1));
		return Integer.parseInt(hour) * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR + Integer.parseInt(minute);
	}
	
	// period has format: HH:mm HH:mm
	// end time will be second HH:mm
	protected String getStringEndTimeForStringPeriod(String period) {
		int length = period.length();
		String hour = String.valueOf(period.charAt(length-5)) + String.valueOf(period.charAt(length-4));
		String minute = String.valueOf(period.charAt(length-2)) + String.valueOf(period.charAt(length-1));
		return hour + AppConst.DATE_TIME.COLON + minute;
	}
	
	
	protected String getDateTimeAfterFewMinuteFromNow(int minute) {
		
		String currentTime = getCurrentTimeString();
		int day = getDayFromStringDate(currentTime);
		int month = getMonthFromStringDate(currentTime);
		int time = getEndTimeFromStringPeriod(currentTime);
		time += minute;
		while (time >= AppConst.DATE_TIME.NUMBER_HOURS_PER_DAY * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR) {
			time -= AppConst.DATE_TIME.NUMBER_HOURS_PER_DAY * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR;
			day++;
			if (day > mDaysInMonth[month-1]) {
				day -= mDaysInMonth[month-1];
				month++;
			}
		}
		String dayString = String.valueOf(day);
		if (dayString.length() < 2) {
			dayString = AppConst.DATE_TIME.ZERO + dayString;
		}
		
		String monthString = String.valueOf(month);
		if (monthString.length() < 2) {
			monthString = AppConst.DATE_TIME.ZERO + monthString;
		}
		
		String hourString = String.valueOf(time / AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR);
		if (hourString.length() < 2) {
			hourString = AppConst.DATE_TIME.ZERO + hourString;
		}
		
		String minuteString = String.valueOf(time % AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR);
		if (minuteString.length() < 2) {
			minuteString = AppConst.DATE_TIME.ZERO + minuteString;
		}
		
		return dayString + AppConst.DATE_TIME.SLASH + monthString + " " + hourString + ":" + minuteString;
	}
	
	
	
	protected boolean isTwoEventOverlap(String fromDateTime1, 
										String toDateTime1, 
										boolean isHasPeriod1, 
										String period1, 
										String fromDateTime2, 
										String toDateTime2, 
										boolean isHasPeriod2, 
										String period2) {
		int fromDay1 = getNumberOfDayFromThisYearForDate(getDayFromStringDate(fromDateTime1), getMonthFromStringDate(fromDateTime1));
		int fromTime1 = getHourFromStringDate(fromDateTime1) * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR + getMinuteFromStringDate(fromDateTime1);
		int toDay1 = getNumberOfDayFromThisYearForDate(getDayFromStringDate(toDateTime1), getMonthFromStringDate(toDateTime1));
		int toTime1 = getHourFromStringDate(toDateTime1) * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR + getMinuteFromStringDate(toDateTime1);
		int fromDay2 = getNumberOfDayFromThisYearForDate(getDayFromStringDate(fromDateTime2), getMonthFromStringDate(fromDateTime2));
		int fromTime2 = getHourFromStringDate(fromDateTime2) * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR + getMinuteFromStringDate(fromDateTime2);
		int toDay2 = getNumberOfDayFromThisYearForDate(getDayFromStringDate(toDateTime2), getMonthFromStringDate(toDateTime2));
		int toTime2 = getHourFromStringDate(toDateTime2) * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR + getMinuteFromStringDate(toDateTime2);
		for (int i = fromDay1; i <= toDay1; i++) {
			if (i >= fromDay2 && i <= toDay2) {
				int startTime1 = 0, endTime1 = AppConst.DATE_TIME.NUMBER_HOURS_PER_DAY * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR - 1;
				if (i == fromDay1) {
					startTime1 = fromTime1;
				}				
				if (i == toDay1) {
					endTime1 = toTime1;
				}
				
				if (isHasPeriod1) {
					startTime1 = getStartTimeFromStringPeriod(period1);
					endTime1 = getEndTimeFromStringPeriod(period1);
				}
				
				int startTime2 = 0, endTime2 = AppConst.DATE_TIME.NUMBER_HOURS_PER_DAY * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR - 1;
				if (i == fromDay2) {
					startTime2 = fromTime2;
				}				
				if (i == toDay2) {
					endTime2 = toTime2;
				}
				
				if (isHasPeriod2) {
					startTime2 = getStartTimeFromStringPeriod(period2);
					endTime2 = getEndTimeFromStringPeriod(period2);
				}
								
				if (startTime1 <= startTime2 && startTime2 < endTime1) {
					return true;
				}
				if (startTime1 < endTime2 && endTime2 <= endTime1) {
					return true;
				}
				if (startTime2 <= startTime1 && startTime1 < endTime2) {
					return true;
				}
				if (startTime2 < endTime1 && endTime1 <= endTime2) {
					return true;
				}
				
			}
		}
		return false;
	}
	
	protected boolean isEventOverlapWithRepeating(	String startDateTime, 
													String endDateTime, 
													boolean isHasPeriod, 
													String period,
													String repeatedDay, 
													String periodRepeated ) {
		int fromDay = getNumberOfDayFromThisYearForDate(getDayFromStringDate(startDateTime), getMonthFromStringDate(startDateTime));
		int fromTime = getHourFromStringDate(startDateTime) * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR + getMinuteFromStringDate(startDateTime);
		int toDay = getNumberOfDayFromThisYearForDate(getDayFromStringDate(endDateTime), getMonthFromStringDate(endDateTime));
		int toTime = getHourFromStringDate(endDateTime) * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR + getMinuteFromStringDate(endDateTime);	
		int dayInWeekRepeated = getDayInWeekForDate(repeatedDay);								
		for (int i=fromDay; i<=toDay; i++) {
			
			int startTime = 0, endTime = AppConst.DATE_TIME.NUMBER_HOURS_PER_DAY * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR - 1;
			if (i==fromDay) {
				startTime = fromTime;
			}				
			if (i==toDay) {
				endTime = toTime;
			}
				
			if (isHasPeriod) {
				startTime = getStartTimeFromStringPeriod(period);
				endTime = getEndTimeFromStringPeriod(period);
			}
		
			String date = getDateForNumberOfDays(i);
			int dayInWeek = getDayInWeekForDate(date);
			
			if (dayInWeek == dayInWeekRepeated) {
				int startRepeatedTime = getStartTimeFromStringPeriod(periodRepeated);
				int endRepeatedTime = getEndTimeFromStringPeriod(periodRepeated);
				if (startTime <= startRepeatedTime && startRepeatedTime < endTime) {
					return true;
				}
				if (startTime < endRepeatedTime && endRepeatedTime <= endTime) {
					return true;
				}
				
				if (startRepeatedTime <= startTime && startTime < endRepeatedTime) {
					return true;
				}
				if (startRepeatedTime < endTime && endTime <= endRepeatedTime) {
					return true;
				}
			}
		}	
		return false;									
	}
	
	
	protected int[] getTimetableForDate(String date, ArrayList<Task> allTasks) {
		
		int[] result = new int[] {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
		int dayInWeek = getDayInWeekForDate(date);
		int day = getNumberOfDayFromThisYearForDate(getDayFromStringDate(date), getMonthFromStringDate(date));
		for (int i=0; i<allTasks.size(); i++) {
			Task task = allTasks.get(i);
			String startDate = task.getStartDate();
			String endDate = task.getEndDate();
			if (startDate.equals("") || endDate.equals("")) {
				continue;
			}
			
			int fromDay = getNumberOfDayFromThisYearForDate(getDayFromStringDate(startDate), getMonthFromStringDate(startDate));
			int fromTime = getHourFromStringDate(startDate) * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR + getMinuteFromStringDate(startDate);
			int toDay = getNumberOfDayFromThisYearForDate(getDayFromStringDate(endDate), getMonthFromStringDate(endDate));
			int toTime = getHourFromStringDate(endDate) * AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR + getMinuteFromStringDate(endDate);
			
			if (task.getRepeatedType() != AppConst.REPEATED_TYPE.EVERY_WEEK) {
				if (day>=fromDay && day<=toDay) {
					int startTime = 0, endTime = AppConst.DATE_TIME.NUMBER_HOURS_PER_DAY;
					if (day == fromDay) {
						startTime = fromTime / AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR;
					}
					if (day == toDay) {
						endTime = (toTime + AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR - 1) / AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR;
					}
					if (task.getRepeatedType() > 0) {
						startTime = getStartTimeFromStringPeriod(task.getPeriod()) / AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR;
						endTime = (getEndTimeFromStringPeriod(task.getPeriod()) + AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR - 1) / AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR;
					}
					for (int j = startTime; j < endTime; j++) {
						if (j >= AppConst.DATE_TIME.START_TIMETABLE_TIME && j < AppConst.DATE_TIME.END_TIMETABLE_TIME) {
							result[j-AppConst.DATE_TIME.START_TIMETABLE_TIME] = i;
						}
					}
				}
			} else {
				int fromDayInWeek = getDayInWeekForDate(startDate);
				if (day >= fromDay && fromDayInWeek == dayInWeek) {
					int startTime = getStartTimeFromStringPeriod(task.getPeriod()) / AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR;
					int endTime = (getEndTimeFromStringPeriod(task.getPeriod()) + AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR - 1) / AppConst.DATE_TIME.NUMBER_MINUTES_PER_HOUR;
					for (int j=startTime; j<endTime; j++) {
						if (j >= AppConst.DATE_TIME.START_TIMETABLE_TIME && j < AppConst.DATE_TIME.END_TIMETABLE_TIME) {
							result[j-AppConst.DATE_TIME.START_TIMETABLE_TIME] = i;
						}
					}
				}
			}
		}
		
		return result;
		
	}
	
	

}
```
###### MainApp.java
``` java
package cs2103;
import java.util.*;

import javax.swing.*;
import java.awt.Toolkit;
import java.util.Timer;
import java.util.TimerTask;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.FlowLayout;
import java.awt.event.*;
import java.awt.Rectangle;

import javax.swing.text.DefaultCaret;

public class MainApp {
    
	private static TableHelper mTableHelper = new TableHelper();
	private static MainLogic mMainLogic = new MainLogic();
	
    static JButton enterButton;
    public static JTextArea output;
    public static JTextField input;
    static JFrame frame;
    static JPanel panel;
    static JTable table;
    static Toolkit toolkit;
    static Timer timer;								
    										
    static ArrayList<Task> dataTaskList = new ArrayList<Task>();
    static int windowHeight = AppConst.UI_CONST.DEFAULT_WINDOW_HEIGHT;
	static int windowWidth = AppConst.UI_CONST.DEFAULT_WINDOW_WIDTH;
    static int userCommandCount = 0;
    static int userScrollCount = 0;
    static int mTableRowCount = 0;
    
	public MainApp() {

	}
	
	public static void main(String[] argv) {

		try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        }
        catch (Exception ex) {
            ex.printStackTrace();
        }
		
        ArrayListPointer dataTaskListPointer = new ArrayListPointer();
        
        toolkit = Toolkit.getDefaultToolkit();
        Dimension d = toolkit.getScreenSize();
		windowWidth = (int)(d.width * AppConst.UI_CONST.DEFAULT_RATIO);
        
        // Input a showall command upon launching Todoer
        String message = mMainLogic.process(AppConst.COMMAND_TYPE.SHOW_ALL, dataTaskListPointer);
        dataTaskList = dataTaskListPointer.getPointer();
        mTableRowCount = dataTaskList.size();
        mTableHelper.setDataListForTable(dataTaskList);
        mTableHelper.createTableToDisplayTasks();    
        
        openToDoListWindow();

        displayMessage(AppConst.MESSAGE.WELCOME);
        assert message != null;
        displayMessage(message);
        
        // Set schedule for reminding
        
	    timer = new Timer();
		timer.scheduleAtFixedRate(new RemindTask(), 0, AppConst.UI_CONST.DEFAULT_TIME_REMIND);
	}
	
	// Display message in the display message box
	private static void displayMessage(String message) {
		output.append(message);
	}

	/* 
	** The window contains a table box to display table, a display message box to display message,
	** and the user input field for user typing commands
	*/
	private static void openToDoListWindow() {
	
        // Create a window for app
        frame = new JFrame(AppConst.UI_CONST.APP_NAME);
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.setOpaque(true);
        
        // Create text area to display message to users
        ButtonListener buttonListener = new ButtonListener();
        output = new JTextArea(windowHeight, windowWidth);
        output.setBackground(Color.white);
        output.setForeground(Color.black);
        output.setLineWrap(true);
        output.setWrapStyleWord(true);
        output.setEditable(false);
        
        table = mTableHelper.getTable();
		// Create scroll bar if table area is full        
        JScrollPane scroller = new JScrollPane(table);
        scroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
        scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        table.setFillsViewportHeight(true);

		// Create scroll bar if text area is full
        JScrollPane scroller2 = new JScrollPane(output);
        scroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
        scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        
        // Create input panel to get user's command
        JPanel inputpanel = new JPanel();
        inputpanel.setLayout(new FlowLayout());
        input = new JTextField(windowWidth);
        input.setBackground(Color.white);
        input.setForeground(Color.red);
        input.setCaretColor(Color.blue);
        input.setActionCommand(AppConst.UI_CONST.ENTER);  
        input.addActionListener(buttonListener);
        input.addKeyListener(new KeyAdapter() {
            public void keyPressed(KeyEvent evt) {
                panelKeyPressAction(evt);
            }
        });
        
        // Added the table box, display message box and the input to the panel
        DefaultCaret caret = (DefaultCaret) output.getCaret();
        caret.setUpdatePolicy(DefaultCaret.ALWAYS_UPDATE);
        panel.add(scroller);
        panel.add(scroller2);
        inputpanel.add(input);
        panel.add(inputpanel);
        
        frame.getContentPane().add(BorderLayout.CENTER, panel);
        frame.pack();
        frame.setLocationByPlatform(true);
        frame.setVisible(true);
        frame.setResizable(false);
        
        input.requestFocus();
        userCommandCount = 0;
        displayMessage(AppConst.UI_CONST.COMMAND_MESSAGE);
    } 

    public static class ButtonListener implements ActionListener
    {
        public void actionPerformed(final ActionEvent ev)
        {
            if (!input.getText().trim().equals(""))
            {
                String cmd = ev.getActionCommand();
                if (AppConst.UI_CONST.ENTER.equals(cmd))
                {
                	String userCommand = input.getText();
                	output.setText("");
                	displayMessage(AppConst.UI_CONST.COMMAND_MESSAGE + userCommand + AppConst.UI_CONST.NEW_LINE);
                	
                	// Clear text field
                    if (userCommand.equals(AppConst.COMMAND_TYPE.CLEAR)) {
                        output.setText("");
                        mMainLogic.deleteAllUserCommands();
                        displayMessage(AppConst.UI_CONST.COMMAND_MESSAGE);
                        userCommandCount = 0;
                    } else {
                    	
                    	// Executed user command
                        ArrayListPointer dataTaskListPointer = new ArrayListPointer();   
                        dataTaskListPointer.setPointer(dataTaskList);
                    	String message = mMainLogic.process(userCommand, dataTaskListPointer);
                        dataTaskList = dataTaskListPointer.getPointer();
                        mTableRowCount = dataTaskList.size();
                        userScrollCount = 0;
                        mTableHelper.setDataListForTable(dataTaskList);
                        String[] commands = userCommand.split(" ");
                        if (commands[0].equals(AppConst.COMMAND_TYPE.TIMETABLE)) {
                        	displayMessage(mTableHelper.createTimetable(userCommand));
                        	mTableRowCount = mTableHelper.getTableRowCount();
                        } else if (commands[0].equals(AppConst.COMMAND_TYPE.HELP)) {
                        	mTableHelper.createTableForHelpDocument();
                        } else if (message == null) {
                    		displayMessage(AppConst.MESSAGE.GOODBYE);
                    		frame.setVisible(false);
                    		frame.dispose();
                    	} else {
                    		mTableHelper.createTableToDisplayTasks();
                    		displayMessage(message);
                    	}
                    }
                    userCommandCount = 0;
                }
            }
            input.setText("");
            input.requestFocus();
        }
    }
    
    // Support historical user commands by press key UP and DOWN
	// Support scroll table by press key PgUp and PgDn
    private static void panelKeyPressAction(KeyEvent event) {
    
        if (event.getKeyCode() == KeyEvent.VK_UP || event.getKeyCode() == KeyEvent.VK_DOWN) {
            String userCommand = "";
            if (event.getKeyCode() == KeyEvent.VK_UP) {
                userCommandCount++;
                if (userCommandCount > mMainLogic.getOldUserCommandSize()) {
                    userCommandCount--;
                }
                userCommand = mMainLogic.getOldUserCommand(userCommandCount);
            } else {
                userCommandCount--;
                if (userCommandCount < 0) {
                    userCommandCount = 0;
                } else {
                    userCommand = mMainLogic.getOldUserCommand(userCommandCount);
                }
            }
            input.requestFocus();
            input.setText(userCommand);
            input.setCaretPosition(userCommand.length());
        }
        
        if (event.getKeyCode() == KeyEvent.VK_PAGE_DOWN) {
        	userScrollCount++;
        	if (userScrollCount + AppConst.UI_CONST.MAX_NUMBER_ROWS > mTableRowCount) {
        		userScrollCount--;
        	}
        	
        	table.scrollRectToVisible(new Rectangle(0, 
        											userScrollCount * table.getRowHeight(), 
        											table.getWidth(), 
        											AppConst.UI_CONST.MAX_NUMBER_ROWS * table.getRowHeight()));
        	
        }
        if (event.getKeyCode() == KeyEvent.VK_PAGE_UP) {
        	
        	userScrollCount--;
        	if (userScrollCount < 0) {
        		userScrollCount++;
        	}
        	
        	table.scrollRectToVisible(new Rectangle(0, 
        											userScrollCount * table.getRowHeight(), 
        											table.getWidth(), 
        											AppConst.UI_CONST.MAX_NUMBER_ROWS * table.getRowHeight()));
        }
    }
    
    public static class RemindTask extends TimerTask {
	
		@Override
		public void run() {
			
			/*
			* Get the list of tasks with the reminder time is coming
			* User can set the reminder time for a task by using repeat id <id> <time>
			*/
			ArrayListPointer dataTaskListPointer = new ArrayListPointer();   
            dataTaskListPointer.setPointer(dataTaskList);
			String message = mMainLogic.process(AppConst.COMMAND_TYPE.REMIND, dataTaskListPointer);
			
			if (message != null) {				
				
				dataTaskList = dataTaskListPointer.getPointer();
				mTableRowCount = dataTaskList.size();
				userScrollCount = 0;
				mTableHelper.setDataListForTable(dataTaskList);
				mTableHelper.createTableToDisplayTasks();
				output.setText("");
				displayMessage(message);
				
				// show notification to users
				// option pane with no buttons.
				JOptionPane opt = new JOptionPane(	AppConst.MESSAGE.NOTIFICATIONS, 
													JOptionPane.INFORMATION_MESSAGE, 
													JOptionPane.DEFAULT_OPTION, 
													null, 
													new Object[]{AppConst.UI_CONST.OK_BUTTON}); 
													
		  		final JDialog dlg = opt.createDialog(AppConst.UI_CONST.NOTIFICATION);
		  		new Thread(new Runnable() {
					public void run() {		
		  				try {
		  					/* 
		  					* Turn on the notification
		  					* User can turn off by press ENTER
		  					* If not, after timeDismiss seconds, the notification will be turned off
		  					*/
							Thread.sleep(AppConst.UI_CONST.DEFAULT_TIME_DISMISS);
							dlg.dispose();
						} catch (Throwable th) {
							
						}
		  			}
		  		}).start();
		  		dlg.setVisible(true);
			}
			//toolkit.beep();
		}
	}
    

}
```
###### TableHelper.java
``` java
package cs2103;

import java.awt.Color;
import java.awt.Component;
import java.util.ArrayList;

import javax.swing.JTable;
import javax.swing.SwingConstants;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;

public class TableHelper {
	
	private DateTimeHelper mDateTimeHelper = new DateTimeHelper();
	private CommandParser mCommandParser = new CommandParser();
	private ArrayList<Task> mDataTaskList = new ArrayList<Task>();
    
 // column to display in table
    String[] mColumnNames = AppConst.UI_CONST.TASK_COLUMN_NAMES;
    String[] mTimeTableColumnNames = AppConst.UI_CONST.TIMETABLE_COLUMN_NAMES;
    String[] mHelpColumnNames = AppConst.UI_CONST.HELP_TABLE_COLUMN_NAMES;
    int[] mColumnWidth = AppConst.UI_CONST.TASK_COLUMN_WIDTH;
    
    private static JTable mTable;
    
	public TableHelper() {
		
		// Create table to display tasks
	    mTable = new JTable() {
	    	
		    @Override
			public Component prepareRenderer(TableCellRenderer renderer, int row, int col) {
				Component comp = super.prepareRenderer(renderer, row, col);
				Object value = getModel().getValueAt(row, col);
				comp.setBackground(Color.white);
				
				// Help document table
				if (getModel().getColumnCount() == AppConst.UI_CONST.HELP_TABLE_COLUMN_NAMES.length) {
					if (row == AppConst.UI_CONST.COMMAND_ROW1 || row == AppConst.UI_CONST.COMMAND_ROW2) {
						comp.setBackground(Color.green);
					}
					return comp;
				}
				
				/*
				* If the table is displaying list of tasks, column priority will display the priority of tasks
				* either High, Medium, or Low.
				* otherwise, the table is displaying the timetable
				* Check the value of column priority to check which data the table is displaying.
				*/
				
				Object checkValue = getModel().getValueAt(row, AppConst.UI_CONST.COLUMN_PRIORITY);
				if (checkValue.equals(AppConst.UI_CONST.HIGH) || checkValue.equals(AppConst.UI_CONST.MEDIUM) || checkValue.equals(AppConst.UI_CONST.LOW)) {
					if (col == AppConst.UI_CONST.COLUMN_PRIORITY) {
						if (value.equals(AppConst.UI_CONST.HIGH)) {
							comp.setBackground(Color.red);
						} else if (value.equals(AppConst.UI_CONST.MEDIUM)) {
							comp.setBackground(Color.yellow);
						} else if (value.equals(AppConst.UI_CONST.LOW)) {
							comp.setBackground(Color.green);
						}
					}
				} else {
					String st = (String)value;
					if (st.endsWith(AppConst.TASK_FIELD.HIGH)) {
						comp.setBackground(Color.red);
					} else if (st.endsWith(AppConst.TASK_FIELD.MEDIUM)) {
						comp.setBackground(Color.yellow);
					} else if (st.endsWith(AppConst.TASK_FIELD.LOW)) {
						comp.setBackground(Color.green);
					}
				}
				return comp;
			}
	    };
	    
	    mTable.setRowHeight(AppConst.UI_CONST.ROW_HEIGHT_DEFAULT);   
	    
	    createTableToDisplayTasks();
	}
	
	protected JTable getTable() {
		return mTable;
	}

	protected int getTableRowCount() {
		return mTable.getRowCount();
	}
	
	protected void setDataListForTable(ArrayList<Task> tasks) {
		mDataTaskList = tasks;
	}
	
	/* Get the data to display in the table for a task	
	* Column 0: index number of a task in the table, 
	* user can use this index instead of task name for commands
	* Column 1: Task name
	* Column 2: Deadline for task
	* Column 3: Start date/time for task,
	* for event task, the value will be the start time and date of the event
	* for recurrent task type repeat from date to date, the value will be the start date of event
	* for recurrent task type repeat every day or a day in week, the value will the the start time of each day
	* Column 4: End date/time for task,
	* for event task, the value will be the end time and date of the event
	* for recurrent task type repeat from date to date, the value will be the end date of event
	* for recurrent task type repeat every day or a day in week, the value will the the end time of each day
	* Column 5: Period of an recurrent task
	* For recurrent task type repeat from date to date, the value will be the start and end time of each day
	* For recurrent task type repeat every day or a day in week, the value will either "Every day" or "Every <a day in week>"
	* Column 6: Priority of a task, for display, it's either High, Medium or Low, comes with the color
	* Column 7: Group name of a task
	* Column 8: Status of a task, either "done" or "undone"
	*/
	public String[] getDataFromTask(Task task, int i) {
	
		String[] data = new String[mColumnNames.length];
		data[AppConst.UI_CONST.COLUMN_INDEX] = String.valueOf(i + 1);
		data[AppConst.UI_CONST.COLUMN_TASK_NAME] = removeSlash(task.getName());
		data[AppConst.UI_CONST.COLUMN_DEADLINE] = mDateTimeHelper.convertToDisplayFormat(task.getDeadline());
		
		int repeatedType = task.getRepeatedType();
		switch (repeatedType) {
			case AppConst.REPEATED_TYPE.FROM_TO: 
				data[AppConst.UI_CONST.COLUMN_PERIOD] = task.getPeriod();
				data[AppConst.UI_CONST.COLUMN_START_DATE_TIME] = mDateTimeHelper.convertDateMonthToDisplayFormat(task.getStartDate());
				data[AppConst.UI_CONST.COLUMN_END_DATE_TIME] = mDateTimeHelper.convertDateMonthToDisplayFormat(task.getEndDate());
				break;
			case AppConst.REPEATED_TYPE.EVERY_WEEK:
			case AppConst.REPEATED_TYPE.EVERYDAY:
				data[AppConst.UI_CONST.COLUMN_START_DATE_TIME] = mDateTimeHelper.getStringStartTimeForStringPeriod(task.getPeriod());
				data[AppConst.UI_CONST.COLUMN_END_DATE_TIME] = mDateTimeHelper.getStringEndTimeForStringPeriod(task.getPeriod());
				if (repeatedType == AppConst.REPEATED_TYPE.EVERY_WEEK) { 
					data[AppConst.UI_CONST.COLUMN_PERIOD] = AppConst.UI_CONST.EVERY + mDateTimeHelper.getStringDayInWeekForDate(task.getStartDate());
				} else {
					data[AppConst.UI_CONST.COLUMN_PERIOD] = AppConst.UI_CONST.EVERYDAY;
				}
				break;
			
			default: 
				data[AppConst.UI_CONST.COLUMN_START_DATE_TIME] = mDateTimeHelper.convertToDisplayFormat(task.getStartDate());
				data[AppConst.UI_CONST.COLUMN_END_DATE_TIME] = mDateTimeHelper.convertToDisplayFormat(task.getEndDate());
				data[AppConst.UI_CONST.COLUMN_PERIOD] = "";
		}
		data[AppConst.UI_CONST.COLUMN_PRIORITY] = task.getPriority();
		data[AppConst.UI_CONST.COLUMN_PRIORITY] = data[AppConst.UI_CONST.COLUMN_PRIORITY].substring(0, 1).toUpperCase() + data[AppConst.UI_CONST.COLUMN_PRIORITY].substring(1);
		data[AppConst.UI_CONST.COLUMN_GROUP] = removeSlash(task.getGroup());
		data[AppConst.UI_CONST.COLUMN_STATUS] = task.getStatus();
		data[AppConst.UI_CONST.COLUMN_STATUS] = data[AppConst.UI_CONST.COLUMN_STATUS].substring(0, 1).toUpperCase() + data[AppConst.UI_CONST.COLUMN_STATUS].substring(1);
		return data;
	}
	
	/*
	** Users have to use slash "\" in front if they use a key word in the task name or task group.
	** for display, we remove the slash before displaying
	*/
	protected String removeSlash(String st) {
		if (st == null || st.equals("")) {
			return st;
		}
		
		String splits[] = st.split(" ");
		if (st.length() == 0) {
			return st;
		}
		
		String[] keys = AppConst.KEY_WORD.keywords;
		
		for(int i = 0; i < splits.length; i++) {
			if (splits[i].startsWith(AppConst.UI_CONST.SLASH) && splits[i].length() > 1) {
				String s = splits[i].substring(1, splits[i].length());
				boolean isKeyword = false;
				for(int j = 0; j < keys.length; j++) {
					if (keys[j].equals(s)) {
						isKeyword = true;
						break;
					}
				}
				if (isKeyword) {
					splits[i] = s;
				}
			}
		}
		
		String result = "";
		for(int i = 0; i < splits.length; i++) {
			if (i > 0) {
				result += " ";
			}
			result += splits[i];
		}
		return result;
		
	}
	
	protected void createTableToDisplayTasks() {
    	DefaultTableModel tableModel = (DefaultTableModel)mTable.getModel();
        tableModel.setColumnIdentifiers(mColumnNames);
        tableModel.setRowCount(0);
        
        for (int i = 0 ; i < mColumnNames.length; i++) {
        	if (i != AppConst.UI_CONST.COLUMN_STATUS) {
        		mTable.getColumnModel().getColumn(i).setPreferredWidth(mColumnWidth[i]);
        		mTable.getColumnModel().getColumn(i).setMaxWidth(mColumnWidth[i]);
        	}
        }
        
        // Set data for table
        for (int i = 0; i < mDataTaskList.size(); i++) {
            String[] data = getDataFromTask(mDataTaskList.get(i), i);
            tableModel.addRow(data);
        }
    
    	DefaultTableCellRenderer centerRender = new DefaultTableCellRenderer();
		centerRender.setHorizontalAlignment(SwingConstants.CENTER);
		for (int i = 0 ; i < mColumnNames.length; i++) {
			if (i != AppConst.UI_CONST.COLUMN_GROUP && i != AppConst.UI_CONST.COLUMN_TASK_NAME ) {
				mTable.getColumnModel().getColumn(i).setCellRenderer(centerRender);
        	}
        }
       
        ((DefaultTableCellRenderer)mTable.getTableHeader().getDefaultRenderer()).setHorizontalAlignment(SwingConstants.CENTER);
        mTable.setModel(tableModel);
        tableModel.fireTableDataChanged();
    }
	
	public void createTableForHelpDocument() {
		DefaultTableModel tableModel = (DefaultTableModel)mTable.getModel();
		tableModel.setRowCount(0);
		tableModel.setDataVector(AppConst.UI_CONST.HELP_ROW, mHelpColumnNames);
		
		for (int i = 0 ; i < mHelpColumnNames.length; i++) {
        	if (AppConst.UI_CONST.HELP_COLUMN_WIDTH[i] != 0) {
        		mTable.getColumnModel().getColumn(i).setPreferredWidth(AppConst.UI_CONST.HELP_COLUMN_WIDTH[i]);
        		mTable.getColumnModel().getColumn(i).setMaxWidth(AppConst.UI_CONST.HELP_COLUMN_WIDTH[i]);
        	}
        }
		DefaultTableCellRenderer centerRender = new DefaultTableCellRenderer();
		centerRender.setHorizontalAlignment(SwingConstants.CENTER);
		for (int i = 0 ; i < mHelpColumnNames.length; i++) {
			mTable.getColumnModel().getColumn(i).setCellRenderer(centerRender);
        }
		
        mTable.setModel(tableModel);
        tableModel.fireTableDataChanged();
	}
	
	public String createTimetable(String userCommand) {
	    
    	userCommand = removeSpace(userCommand);    		
    	String startDate = mCommandParser.getStartDateForTimetable(userCommand);
    	String endDate = mCommandParser.getEndDateForTimetable(userCommand);
    	if (startDate == null || startDate.equals("") || endDate == null || endDate.equals("")) {
    		createTableToDisplayTasks();
    		return AppConst.MESSAGE.INVALID_DATE_TIME_FORMAT;
    	}
    	
    	int from = mDateTimeHelper.getNumberOfDayFromThisYearForDate(mDateTimeHelper.getDayFromStringDate(startDate), mDateTimeHelper.getMonthFromStringDate(startDate));
    	int to = mDateTimeHelper.getNumberOfDayFromThisYearForDate(mDateTimeHelper.getDayFromStringDate(endDate), mDateTimeHelper.getMonthFromStringDate(endDate));
		
    	if (from > to) {
			createTableToDisplayTasks();
			return AppConst.MESSAGE.INVALID_DATE_TIME_FORMAT;
		}
		DefaultTableModel tableModel = (DefaultTableModel)mTable.getModel();
    	tableModel.setRowCount(0);
    	tableModel.setColumnIdentifiers(mTimeTableColumnNames);		
    	mTable.getColumnModel().getColumn(0).setPreferredWidth(AppConst.UI_CONST.DEFAULT_COLUMN_WIDTH);
    	mTable.getColumnModel().getColumn(0).setMaxWidth(AppConst.UI_CONST.DEFAULT_COLUMN_WIDTH);
		 
		for(int i = from; i <= to; i++) {   	
			String date = mDateTimeHelper.getDateForNumberOfDays(i);
			
			// TIME_ZERO = 00:00
			date += AppConst.UI_CONST.TIME_ZERO;
			int[] timetable = mDateTimeHelper.getTimetableForDate(date, mDataTaskList);
			String[] data = new String[mTimeTableColumnNames.length];
			data[0] = mDateTimeHelper.convertDateMonthToDisplayFormat(date) + " (" + mDateTimeHelper.getStringDayInWeekForDate(date) + ")";
			for(int j = 1; j < mTimeTableColumnNames.length; j++) {
				if (timetable[j-1] != -1) {
					data[j] = mDataTaskList.get(timetable[j - 1]).getName() + AppConst.UI_CONST.SPACE + AppConst.TASK_FIELD.PRIORITY + mDataTaskList.get(timetable[j - 1]).getPriority();
				} else {
					data[j] = "";
				}
			}
			tableModel.addRow(data);
		}
		tableModel.fireTableDataChanged();
    	return "";
    }
	
	private String removeSpace(String userCommand) {
		String[] commands = userCommand.split(" ");
		String result = "";
		for(int i = 0; i < commands.length; i++) {
			if (!commands[i].equals("") && !commands[i].equals(" ")) {
				if (result.length() > 0) {
					result += " ";
				}
				result += commands[i];
			}
		}
		return result;
	}
	
}
```
